from typing import List, Optional, Sequence, Tuple, overload

from typing_extensions import Literal

class ZUid:
    address: str
    time: float

class ZNotice:
    kind: int
    cls: str
    instance: str
    uid: ZUid
    time: int
    port: int
    auth: bool
    recipient: Optional[str]
    sender: Optional[str]
    opcode: Optional[str]
    format: str
    other_fields: List[str]
    fields: List[str]
    _charset: Optional[str]
    def __init__(
        self,
        kind: int = ...,
        cls: str = ...,
        instance: str = ...,
        uid: ZUid = ...,
        time: int = ...,
        port: int = ...,
        auth: bool = ...,
        recipient: Optional[str] = ...,
        sender: Optional[str] = ...,
        opcode: Optional[str] = ...,
        format: str = ...,
        other_fields: List[str] = ...,
        fields: List[str] = ...,
        _charset: Optional[str] = ...,
        message: str = ...,
    ): ...
    def getmessage(self) -> str: ...
    def setmessage(self, newmsg: str) -> None: ...
    message = property(getmessage, setmessage)
    @property
    def charset(self) -> Optional[str]: ...
    def send(self) -> None: ...

def initialize() -> None: ...
def openPort() -> int: ...
def getFD() -> int: ...
def setFD(fd: int) -> None: ...
def sub(cls: str, instance: str, recipient: str) -> None: ...
def subAll(lst: Sequence[Tuple[str, str, str]]) -> None: ...
def unsub(cls: str, instance: str, recipient: str) -> None: ...
def cancelSubs() -> None: ...
@overload
def receive(block: Literal[True]) -> ZNotice: ...
@overload
def receive(block: bool = ...) -> Optional[ZNotice]: ...
def sender() -> str: ...
def realm() -> str: ...
def dump_session() -> bytes: ...
def load_session(session: bytes) -> None: ...
def getSubscriptions() -> List[Tuple[str, str, str]]: ...
