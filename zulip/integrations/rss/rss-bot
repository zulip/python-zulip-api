#!/usr/bin/env python3
#
# RSS integration for Zulip
#

import argparse
import calendar
import errno
import hashlib
import logging
import os
import re
import sys
import time
import urllib.parse
from collections.abc import Callable
from html.parser import HTMLParser
from typing import Any, Dict, List

import feedparser
from markdownify import markdownify
from typing_extensions import override

import zulip

VERSION = "0.9"
RSS_DATA_DIR = os.path.expanduser(os.path.join("~", ".cache", "zulip-rss"))

usage = """Usage: Send summaries of RSS entries for your favorite feeds to Zulip.

This bot requires the feedparser module.

To use this script:

1. Create an RSS feed file containing 1 feed URL per line (default feed
   file location: ~/.cache/zulip-rss/rss-feeds)
2. Subscribe to the stream that will receive RSS updates (default stream: rss)
3. create a ~/.zuliprc as described on https://zulip.com/api/configuring-python-bindings
4. Test the script by running it manually, like this:

/usr/local/share/zulip/integrations/rss/rss-bot

You can customize the location on the feed file and recipient stream, e.g.:

/usr/local/share/zulip/integrations/rss/rss-bot --feed-file=/path/to/my-feeds --stream=my-rss-stream

4. Configure a crontab entry for this script. A sample crontab entry for
processing feeds stored in the default location and sending to the default
stream every 5 minutes is:

*/5 * * * * /usr/local/share/zulip/integrations/rss/rss-bot"""

parser = zulip.add_default_arguments(argparse.ArgumentParser(usage))
parser.add_argument(
    "--stream",
    dest="stream",
    help="The stream to which to send RSS messages.",
    default="rss",
    action="store",
)
parser.add_argument(
    "--topic",
    dest="topic",
    help="A fixed topic to use for RSS messages, overriding the default of the feed title/URL",
    default=None,
    action="store",
)
parser.add_argument(
    "--data-dir",
    dest="data_dir",
    help="The directory where feed metadata is stored",
    default=os.path.join(RSS_DATA_DIR),
    action="store",
)
parser.add_argument(
    "--feed-file",
    dest="feed_file",
    help="The file containing a list of RSS feed URLs to follow, one URL per line",
    default=os.path.join(RSS_DATA_DIR, "rss-feeds"),
    action="store",
)
parser.add_argument(
    "--unwrap",
    dest="unwrap",
    action="store_true",
    help="Convert word-wrapped paragraphs into single lines",
    default=False,
)
parser.add_argument(
    "--math",
    dest="math",
    action="store_true",
    help="Convert $ to $$ (for KaTeX processing)",
    default=False,
)
parser.add_argument(
    "--max-batch-size",
    dest="max_batch_size",
    type=int,
    help="The maximum number of messages to send at once",
    default=3,
    action="store",
)
parser.add_argument(
    "--earliest-entry-age",
    dest="earliest_entry_age",
    type=int,
    help="The earliest date (relative to today) you want to process entries from (in days)",
    default=30,
    action="store",
)
body = parser.add_mutually_exclusive_group()
body.add_argument(
    "--strip",
    dest="strip",
    action="store_true",
    help="Strip HTML tags from body",
)
body.add_argument(
    "--markdownify",
    dest="strip",
    action="store_false",
    help="Convert body from HTML to Markdown",
)

opts = parser.parse_args()


def mkdir_p(path: str) -> None:
    # Python doesn't have an analog to `mkdir -p` < Python 3.2.
    try:
        os.makedirs(path)
    except OSError as e:
        if e.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise


try:
    mkdir_p(opts.data_dir)
except OSError:
    # We can't write to the logfile, so just print and give up.
    print(f"Unable to store RSS data at {opts.data_dir}.", file=sys.stderr)
    sys.exit(1)

log_file = os.path.join(opts.data_dir, "rss-bot.log")
log_format = "%(asctime)s: %(message)s"
logging.basicConfig(format=log_format)

formatter = logging.Formatter(log_format)
file_handler = logging.FileHandler(log_file)
file_handler.setFormatter(formatter)

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
logger.addHandler(file_handler)


def log_error_and_exit(error: str) -> None:
    logger.error(error)
    logger.error(usage)
    sys.exit(1)


class MLStripper(HTMLParser):
    def __init__(self) -> None:
        super().__init__()
        self.reset()
        self.fed: List[str] = []

    @override
    def handle_data(self, data: str) -> None:
        self.fed.append(data)

    def get_data(self) -> str:
        return "".join(self.fed)


def strip_tags(html: str) -> str:
    stripper = MLStripper()
    stripper.feed(html)
    return stripper.get_data()


def compute_entry_hash(entry: Dict[str, Any]) -> str:
    entry_time = entry.get("published", entry.get("updated"))
    entry_id = entry.get("id", entry.get("link"))
    return hashlib.md5((entry_id + str(entry_time)).encode()).hexdigest()  # noqa: S324


def unwrap_text(body: str) -> str:
    # Replace \n by space if it is preceded and followed by a non-\n.
    # Example: '\na\nb\nc\n\nd\n' -> '\na b c\n\nd\n'
    return re.sub("(?<=[^\n])\n(?=[^\n])", " ", body)


def elide_subject(subject: str) -> str:
    max_topic_length = 60
    if len(subject) > max_topic_length:
        subject = subject[: max_topic_length - 3].rstrip() + "..."
    return subject


def get_entry_time(entry: Any) -> tuple[float, bool]:
    entry_time = entry.get("published_parsed", entry.get("updated_parsed"))
    return (calendar.timegm(entry_time), True) if entry_time else (float("-inf"), False)


def send_zulip(entry: Any, feed_name: str) -> Dict[str, Any]:
    body: str = entry.summary
    if opts.unwrap:
        body = unwrap_text(body)

    title = f"**[{entry.title}]({entry.link})**\n" if hasattr(entry, "title") else ""

    def md(html: str) -> str:
        return markdownify(html, escape_underscores=False)

    convert: Callable[[str], str] = strip_tags if opts.strip else md
    content = f"{title}{convert(body)}\n{entry.link}"

    if opts.math:
        content = content.replace("$", "$$")

    message: Dict[str, str] = {
        "type": "stream",
        "to": opts.stream,
        "subject": opts.topic or elide_subject(feed_name),
        "content": content,
    }
    return client.send_message(message)


try:
    with open(opts.feed_file) as f:
        feed_urls: List[str] = [feed.strip() for feed in f.readlines()]
except OSError:
    log_error_and_exit(f"Unable to read feed file at {opts.feed_file}.")

client: zulip.Client = zulip.Client(
    email=opts.zulip_email,
    api_key=opts.zulip_api_key,
    config_file=opts.zulip_config_file,
    site=opts.zulip_site,
    client="ZulipRSS/" + VERSION,
)

for feed_url in feed_urls:
    feed_hashes_file = os.path.join(
        opts.data_dir, urllib.parse.urlparse(feed_url).netloc
    )  # Type: str

    try:
        with open(feed_hashes_file) as f:
            old_feed_hashes = {line.strip(): True for line in f.readlines()}
    except OSError:
        old_feed_hashes = {}

    unhashed_entries: List[tuple[Any, str, float]] = []
    data = feedparser.parse(feed_url)
    feed_name: str = getattr(data.feed, "title", None) or feed_url
    # Safeguard to not process older entries in unordered feeds
    entry_threshold = time.time() - opts.earliest_entry_age * 60 * 60 * 24

    for entry in data.entries:
        entry_hash = compute_entry_hash(entry)
        entry_time, is_time_tagged = get_entry_time(entry)
        if (is_time_tagged and entry_time < entry_threshold) or entry_hash in old_feed_hashes:
            continue
        unhashed_entries.append((entry, entry_hash, entry_time))

    # We process all entries to support unordered feeds,
    # but post only the latest ones in chronological order.
    sorted_entries = sorted(unhashed_entries, key=lambda x: x[2])[-opts.max_batch_size :]

    with open(feed_hashes_file, "a") as f:
        for entry_tuple in sorted_entries:
            entry, entry_hash, _ = entry_tuple

            response: Dict[str, Any] = send_zulip(entry, feed_name)
            if response["result"] != "success":
                logger.error("Error processing %s", feed_url)
                logger.error("%s", response)
                if not old_feed_hashes and entry_tuple == sorted_entries[0]:
                    # This is probably some fundamental problem like the stream not
                    # existing or something being misconfigured, so bail instead of
                    # getting the same error for every RSS entry.
                    log_error_and_exit("Failed to process first message")
            # Go ahead and move on -- perhaps this entry is corrupt.
            f.write(entry_hash + "\n")

    logger.info(
        "Processed %d entries from %s and sent %d zulips",
        len(unhashed_entries),
        feed_url,
        len(sorted_entries),
    )
